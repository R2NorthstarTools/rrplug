/* automatically generated by rust-bindgen 0.63.0 */

#[doc(inline)]
pub use root::*;

#[doc(hidden)]
#[allow(
    non_snake_case,
    non_camel_case_types,
    non_upper_case_globals,
    clippy::missing_safety_doc
)]
pub mod root {
    #[allow(unused_imports)]
    use self::super::root;
    const _VCRT_COMPILER_PREPROCESSOR: u32 = 1;
    const _SAL_VERSION: u32 = 20;
    const __SAL_H_VERSION: u32 = 180000000;
    const _USE_DECLSPECS_FOR_SAL: u32 = 0;
    const _USE_ATTRIBUTES_FOR_SAL: u32 = 0;
    const _CRT_PACKING: u32 = 8;
    const _HAS_EXCEPTIONS: u32 = 1;
    const _HAS_CXX17: u32 = 0;
    const _HAS_CXX20: u32 = 0;
    const _HAS_CXX23: u32 = 0;
    const _HAS_NODISCARD: u32 = 1;
    pub const COMMAND_COMPLETION_MAXITEMS: u32 = 64;
    pub const COMMAND_COMPLETION_ITEM_LENGTH: u32 = 128;
    type va_list = *mut ::std::os::raw::c_char;
    extern "C" {
        pub fn __va_start(arg1: *mut root::va_list, ...);
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct __vcrt_va_list_is_reference {
        pub _address: u8,
    }
    pub const __vcrt_va_list_is_reference___the_value:
        root::__vcrt_va_list_is_reference__bindgen_ty_1 = false;
    pub type __vcrt_va_list_is_reference__bindgen_ty_1 = bool;
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct __vcrt_assert_va_start_is_not_reference {
        pub _address: u8,
    }
    pub type __vcrt_bool = bool;
    extern "C" {
        pub fn __security_init_cookie();
    }
    extern "C" {
        pub fn __security_check_cookie(_StackCookie: usize);
    }
    extern "C" {
        pub fn __report_gsfailure(_StackCookie: usize) -> !;
    }
    extern "C" {
        pub static mut __security_cookie: usize;
    }
    #[repr(C)]
    pub struct IConCommandBaseAccessor__bindgen_vtable(::std::os::raw::c_void);
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct IConCommandBaseAccessor {
        pub vtable_: *const IConCommandBaseAccessor__bindgen_vtable,
    }
    #[test]
    fn bindgen_test_layout_IConCommandBaseAccessor() {
        assert_eq!(
            ::std::mem::size_of::<IConCommandBaseAccessor>(),
            8usize,
            concat!("Size of: ", stringify!(IConCommandBaseAccessor))
        );
        assert_eq!(
            ::std::mem::align_of::<IConCommandBaseAccessor>(),
            8usize,
            concat!("Alignment of ", stringify!(IConCommandBaseAccessor))
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct CCommand {
        pub m_nArgc: i64,
        pub m_nArgv0Size: i64,
        pub m_pArgSBuffer: [::std::os::raw::c_char; 512usize],
        pub m_pArgvBuffer: [::std::os::raw::c_char; 512usize],
        pub m_ppArgv: [*const ::std::os::raw::c_char; 64usize],
    }
    pub const CCommand_COMMAND_MAX_ARGC: root::CCommand__bindgen_ty_1 = 64;
    pub const CCommand_COMMAND_MAX_LENGTH: root::CCommand__bindgen_ty_1 = 512;
    pub type CCommand__bindgen_ty_1 = ::std::os::raw::c_int;
    #[test]
    fn bindgen_test_layout_CCommand() {
        const UNINIT: ::std::mem::MaybeUninit<CCommand> = ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<CCommand>(),
            1552usize,
            concat!("Size of: ", stringify!(CCommand))
        );
        assert_eq!(
            ::std::mem::align_of::<CCommand>(),
            8usize,
            concat!("Alignment of ", stringify!(CCommand))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).m_nArgc) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CCommand),
                "::",
                stringify!(m_nArgc)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).m_nArgv0Size) as usize - ptr as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(CCommand),
                "::",
                stringify!(m_nArgv0Size)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).m_pArgSBuffer) as usize - ptr as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(CCommand),
                "::",
                stringify!(m_pArgSBuffer)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).m_pArgvBuffer) as usize - ptr as usize },
            528usize,
            concat!(
                "Offset of field: ",
                stringify!(CCommand),
                "::",
                stringify!(m_pArgvBuffer)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).m_ppArgv) as usize - ptr as usize },
            1040usize,
            concat!(
                "Offset of field: ",
                stringify!(CCommand),
                "::",
                stringify!(m_ppArgv)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}?ArgC@CCommand@@QEBA_JXZ"]
        pub fn CCommand_ArgC(this: *const root::CCommand) -> i64;
    }
    extern "C" {
        #[link_name = "\u{1}?ArgV@CCommand@@QEBAPEAPEBDXZ"]
        pub fn CCommand_ArgV(this: *const root::CCommand) -> *mut *const ::std::os::raw::c_char;
    }
    extern "C" {
        #[link_name = "\u{1}?ArgS@CCommand@@QEBAPEBDXZ"]
        pub fn CCommand_ArgS(this: *const root::CCommand) -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        #[link_name = "\u{1}?GetCommandString@CCommand@@QEBAPEBDXZ"]
        pub fn CCommand_GetCommandString(
            this: *const root::CCommand,
        ) -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        #[link_name = "\u{1}?Arg@CCommand@@QEBAPEBDH@Z"]
        pub fn CCommand_Arg(
            this: *const root::CCommand,
            nIndex: ::std::os::raw::c_int,
        ) -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        #[link_name = "\u{1}?MaxCommandLength@CCommand@@SAHXZ"]
        pub fn CCommand_MaxCommandLength() -> ::std::os::raw::c_int;
    }
    impl CCommand {
        #[inline]
        pub unsafe fn ArgC(&self) -> i64 {
            CCommand_ArgC(self)
        }
        #[inline]
        pub unsafe fn ArgV(&self) -> *mut *const ::std::os::raw::c_char {
            CCommand_ArgV(self)
        }
        #[inline]
        pub unsafe fn ArgS(&self) -> *const ::std::os::raw::c_char {
            CCommand_ArgS(self)
        }
        #[inline]
        pub unsafe fn GetCommandString(&self) -> *const ::std::os::raw::c_char {
            CCommand_GetCommandString(self)
        }
        #[inline]
        pub unsafe fn Arg(&self, nIndex: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char {
            CCommand_Arg(self, nIndex)
        }
        #[inline]
        pub unsafe fn MaxCommandLength() -> ::std::os::raw::c_int {
            CCommand_MaxCommandLength()
        }
    }
    pub type FnCommandCallback_t =
        ::std::option::Option<unsafe extern "C" fn(command: *const root::CCommand)>;
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct ConCommandBase {
        pub m_pConCommandBaseVTable: *mut ::std::os::raw::c_void,
        pub m_pNext: *mut root::ConCommandBase,
        pub m_bRegistered: bool,
        pub pad_0011: [::std::os::raw::c_char; 7usize],
        pub m_pszName: *const ::std::os::raw::c_char,
        pub m_pszHelpString: *const ::std::os::raw::c_char,
        pub m_nFlags: ::std::os::raw::c_int,
        pub s_pConCommandBases: *mut root::ConCommandBase,
        pub s_pAccessor: *mut root::IConCommandBaseAccessor,
    }
    #[test]
    fn bindgen_test_layout_ConCommandBase() {
        const UNINIT: ::std::mem::MaybeUninit<ConCommandBase> = ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<ConCommandBase>(),
            64usize,
            concat!("Size of: ", stringify!(ConCommandBase))
        );
        assert_eq!(
            ::std::mem::align_of::<ConCommandBase>(),
            8usize,
            concat!("Alignment of ", stringify!(ConCommandBase))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).m_pConCommandBaseVTable) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ConCommandBase),
                "::",
                stringify!(m_pConCommandBaseVTable)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).m_pNext) as usize - ptr as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(ConCommandBase),
                "::",
                stringify!(m_pNext)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).m_bRegistered) as usize - ptr as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(ConCommandBase),
                "::",
                stringify!(m_bRegistered)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).pad_0011) as usize - ptr as usize },
            17usize,
            concat!(
                "Offset of field: ",
                stringify!(ConCommandBase),
                "::",
                stringify!(pad_0011)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).m_pszName) as usize - ptr as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(ConCommandBase),
                "::",
                stringify!(m_pszName)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).m_pszHelpString) as usize - ptr as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(ConCommandBase),
                "::",
                stringify!(m_pszHelpString)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).m_nFlags) as usize - ptr as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(ConCommandBase),
                "::",
                stringify!(m_nFlags)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).s_pConCommandBases) as usize - ptr as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(ConCommandBase),
                "::",
                stringify!(s_pConCommandBases)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).s_pAccessor) as usize - ptr as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(ConCommandBase),
                "::",
                stringify!(s_pAccessor)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}?HasFlags@ConCommandBase@@QEAA_NH@Z"]
        pub fn ConCommandBase_HasFlags(
            this: *mut root::ConCommandBase,
            nFlags: ::std::os::raw::c_int,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}?AddFlags@ConCommandBase@@QEAAXH@Z"]
        pub fn ConCommandBase_AddFlags(
            this: *mut root::ConCommandBase,
            nFlags: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        #[link_name = "\u{1}?RemoveFlags@ConCommandBase@@QEAAXH@Z"]
        pub fn ConCommandBase_RemoveFlags(
            this: *mut root::ConCommandBase,
            nFlags: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        #[link_name = "\u{1}?IsCommand@ConCommandBase@@QEBA_NXZ"]
        pub fn ConCommandBase_IsCommand(this: *const root::ConCommandBase) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}?IsRegistered@ConCommandBase@@QEBA_NXZ"]
        pub fn ConCommandBase_IsRegistered(this: *const root::ConCommandBase) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}?IsFlagSet@ConCommandBase@@QEBA_NH@Z"]
        pub fn ConCommandBase_IsFlagSet(
            this: *const root::ConCommandBase,
            nFlags: ::std::os::raw::c_int,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}?IsFlagSet@ConCommandBase@@SA_NPEAV1@H@Z"]
        pub fn ConCommandBase_IsFlagSet1(
            pCommandBase: *mut root::ConCommandBase,
            nFlags: ::std::os::raw::c_int,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}?GetFlags@ConCommandBase@@QEBAHXZ"]
        pub fn ConCommandBase_GetFlags(this: *const root::ConCommandBase) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "\u{1}?GetNext@ConCommandBase@@QEBAPEAV1@XZ"]
        pub fn ConCommandBase_GetNext(
            this: *const root::ConCommandBase,
        ) -> *mut root::ConCommandBase;
    }
    extern "C" {
        #[link_name = "\u{1}?GetHelpText@ConCommandBase@@QEBAPEBDXZ"]
        pub fn ConCommandBase_GetHelpText(
            this: *const root::ConCommandBase,
        ) -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        #[link_name = "\u{1}?CopyString@ConCommandBase@@QEBAPEADPEBD@Z"]
        pub fn ConCommandBase_CopyString(
            this: *const root::ConCommandBase,
            szFrom: *const ::std::os::raw::c_char,
        ) -> *mut ::std::os::raw::c_char;
    }
    impl ConCommandBase {
        #[inline]
        pub unsafe fn HasFlags(&mut self, nFlags: ::std::os::raw::c_int) -> bool {
            ConCommandBase_HasFlags(self, nFlags)
        }
        #[inline]
        pub unsafe fn AddFlags(&mut self, nFlags: ::std::os::raw::c_int) {
            ConCommandBase_AddFlags(self, nFlags)
        }
        #[inline]
        pub unsafe fn RemoveFlags(&mut self, nFlags: ::std::os::raw::c_int) {
            ConCommandBase_RemoveFlags(self, nFlags)
        }
        #[inline]
        pub unsafe fn IsCommand(&self) -> bool {
            ConCommandBase_IsCommand(self)
        }
        #[inline]
        pub unsafe fn IsRegistered(&self) -> bool {
            ConCommandBase_IsRegistered(self)
        }
        #[inline]
        pub unsafe fn IsFlagSet(&self, nFlags: ::std::os::raw::c_int) -> bool {
            ConCommandBase_IsFlagSet(self, nFlags)
        }
        #[inline]
        pub unsafe fn IsFlagSet1(
            pCommandBase: *mut root::ConCommandBase,
            nFlags: ::std::os::raw::c_int,
        ) -> bool {
            ConCommandBase_IsFlagSet1(pCommandBase, nFlags)
        }
        #[inline]
        pub unsafe fn GetFlags(&self) -> ::std::os::raw::c_int {
            ConCommandBase_GetFlags(self)
        }
        #[inline]
        pub unsafe fn GetNext(&self) -> *mut root::ConCommandBase {
            ConCommandBase_GetNext(self)
        }
        #[inline]
        pub unsafe fn GetHelpText(&self) -> *const ::std::os::raw::c_char {
            ConCommandBase_GetHelpText(self)
        }
        #[inline]
        pub unsafe fn CopyString(
            &self,
            szFrom: *const ::std::os::raw::c_char,
        ) -> *mut ::std::os::raw::c_char {
            ConCommandBase_CopyString(self, szFrom)
        }
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct ConCommand {
        pub _base: root::ConCommandBase,
        pub m_pCommandCallback: root::FnCommandCallback_t,
        pub m_pCompletionCallback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_char,
                arg2: *mut [::std::os::raw::c_char; 128usize],
            ) -> ::std::os::raw::c_int,
        >,
        pub m_nCallbackFlags: ::std::os::raw::c_int,
        pub pad_0054: [::std::os::raw::c_char; 4usize],
        pub unk0: ::std::os::raw::c_int,
        pub unk1: ::std::os::raw::c_int,
    }
    #[test]
    fn bindgen_test_layout_ConCommand() {
        const UNINIT: ::std::mem::MaybeUninit<ConCommand> = ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<ConCommand>(),
            96usize,
            concat!("Size of: ", stringify!(ConCommand))
        );
        assert_eq!(
            ::std::mem::align_of::<ConCommand>(),
            8usize,
            concat!("Alignment of ", stringify!(ConCommand))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).m_pCommandCallback) as usize - ptr as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(ConCommand),
                "::",
                stringify!(m_pCommandCallback)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).m_pCompletionCallback) as usize - ptr as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(ConCommand),
                "::",
                stringify!(m_pCompletionCallback)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).m_nCallbackFlags) as usize - ptr as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(ConCommand),
                "::",
                stringify!(m_nCallbackFlags)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).pad_0054) as usize - ptr as usize },
            84usize,
            concat!(
                "Offset of field: ",
                stringify!(ConCommand),
                "::",
                stringify!(pad_0054)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).unk0) as usize - ptr as usize },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(ConCommand),
                "::",
                stringify!(unk0)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).unk1) as usize - ptr as usize },
            92usize,
            concat!(
                "Offset of field: ",
                stringify!(ConCommand),
                "::",
                stringify!(unk1)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}?Init@ConCommand@@QEAAXXZ"]
        pub fn ConCommand_Init(this: *mut root::ConCommand);
    }
    extern "C" {
        #[link_name = "\u{1}?IsCommand@ConCommand@@QEBA_NXZ"]
        pub fn ConCommand_IsCommand(this: *const root::ConCommand) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}??0ConCommand@@QEAA@XZ"]
        pub fn ConCommand_ConCommand(this: *mut root::ConCommand);
    }
    extern "C" {
        #[link_name = "\u{1}??0ConCommand@@QEAA@PEBD0HPEAX1@Z"]
        pub fn ConCommand_ConCommand1(
            this: *mut root::ConCommand,
            szName: *const ::std::os::raw::c_char,
            szHelpString: *const ::std::os::raw::c_char,
            nFlags: ::std::os::raw::c_int,
            pCallback: *mut ::std::os::raw::c_void,
            pCommandCompletionCallback: *mut ::std::os::raw::c_void,
        );
    }
    impl ConCommand {
        #[inline]
        pub unsafe fn Init(&mut self) {
            ConCommand_Init(self)
        }
        #[inline]
        pub unsafe fn IsCommand(&self) -> bool {
            ConCommand_IsCommand(self)
        }
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
            ConCommand_ConCommand(__bindgen_tmp.as_mut_ptr());
            __bindgen_tmp.assume_init()
        }
        #[inline]
        pub unsafe fn new1(
            szName: *const ::std::os::raw::c_char,
            szHelpString: *const ::std::os::raw::c_char,
            nFlags: ::std::os::raw::c_int,
            pCallback: *mut ::std::os::raw::c_void,
            pCommandCompletionCallback: *mut ::std::os::raw::c_void,
        ) -> Self {
            let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
            ConCommand_ConCommand1(
                __bindgen_tmp.as_mut_ptr(),
                szName,
                szHelpString,
                nFlags,
                pCallback,
                pCommandCompletionCallback,
            );
            __bindgen_tmp.assume_init()
        }
    }
    extern "C" {
        #[link_name = "\u{1}?RegisterConCommand@@YAXPEBDP6AXAEBVCCommand@@@Z0H@Z"]
        pub fn RegisterConCommand(
            name: *const ::std::os::raw::c_char,
            callback: ::std::option::Option<unsafe extern "C" fn(arg1: *const root::CCommand)>,
            helpString: *const ::std::os::raw::c_char,
            flags: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        #[link_name = "\u{1}?RegisterConCommand@@YAXPEBDP6AXAEBVCCommand@@@Z0HP6AH0QEAY0IA@D@Z@Z"]
        pub fn RegisterConCommand1(
            name: *const ::std::os::raw::c_char,
            callback: ::std::option::Option<unsafe extern "C" fn(arg1: *const root::CCommand)>,
            helpString: *const ::std::os::raw::c_char,
            flags: ::std::os::raw::c_int,
            completionCallback: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: *const ::std::os::raw::c_char,
                    arg2: *mut [::std::os::raw::c_char; 128usize],
                ) -> ::std::os::raw::c_int,
            >,
        );
    }
    pub type ConCommandConstructorType = ::std::option::Option<
        unsafe extern "C" fn(
            newCommand: *mut root::ConCommand,
            name: *const ::std::os::raw::c_char,
            callback: root::FnCommandCallback_t,
            helpString: *const ::std::os::raw::c_char,
            flags: ::std::os::raw::c_int,
            parent: *mut ::std::os::raw::c_void,
        ),
    >;
    extern "C" {
        #[link_name = "\u{1}?ConCommandConstructor@@3P6AXPEAVConCommand@@PEBDP6AXAEBVCCommand@@@Z1HPEAX@ZEA"]
        pub static mut ConCommandConstructor: root::ConCommandConstructorType;
    }
}
